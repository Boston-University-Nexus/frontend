{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _index = require('./index');\n\nvar _DnDTypes = require('./DnDTypes');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DnDSource = function DnDSource(resolveDragObjFunc, DecoratedComponent) {\n  var _this = this;\n\n  var dndType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _DnDTypes.DnDTypes.EVENT;\n\n  _classCallCheck(this, DnDSource);\n\n  this.getDragSpec = function () {\n    return {\n      beginDrag: function beginDrag(props, monitor, component) {\n        return _this.resolveDragObjFunc(props);\n      },\n      endDrag: function endDrag(props, monitor, component) {\n        if (!monitor.didDrop()) return;\n        var moveEvent = props.moveEvent,\n            newEvent = props.newEvent,\n            schedulerData = props.schedulerData;\n        var events = schedulerData.events,\n            config = schedulerData.config,\n            viewType = schedulerData.viewType,\n            localeMoment = schedulerData.localeMoment;\n        var item = monitor.getItem();\n        var type = monitor.getItemType();\n        var dropResult = monitor.getDropResult();\n        var slotId = dropResult.slotId,\n            slotName = dropResult.slotName;\n        var newStart = dropResult.start,\n            newEnd = dropResult.end;\n        var initialStart = dropResult.initialStart,\n            initialEnd = dropResult.initialEnd;\n        var action = 'New';\n        var isEvent = type === _DnDTypes.DnDTypes.EVENT;\n\n        if (isEvent) {\n          var event = item;\n\n          if (config.relativeMove) {\n            newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(_index.DATETIME_FORMAT);\n          } else {\n            if (viewType !== _index.ViewTypes.Day) {\n              var tmpMoment = localeMoment(newStart);\n              newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(_index.DATETIME_FORMAT);\n            }\n          }\n\n          newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(_index.DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n          if (config.crossResourceMove === false) {\n            slotId = schedulerData._getEventSlotId(item);\n            slotName = undefined;\n            var slot = schedulerData.getSlotById(slotId);\n            if (!!slot) slotName = slot.name;\n          }\n\n          action = 'Move';\n        }\n\n        var hasConflict = false;\n\n        if (config.checkConflict) {\n          var start = localeMoment(newStart),\n              end = localeMoment(newEnd);\n          events.forEach(function (e) {\n            if (schedulerData._getEventSlotId(e) === slotId && (!isEvent || e.id !== item.id)) {\n              var eStart = localeMoment(e.start),\n                  eEnd = localeMoment(e.end);\n              if (start >= eStart && start < eEnd || end > eStart && end <= eEnd || eStart >= start && eStart < end || eEnd > start && eEnd <= end) hasConflict = true;\n            }\n          });\n        }\n\n        if (hasConflict) {\n          var conflictOccurred = props.conflictOccurred;\n\n          if (conflictOccurred != undefined) {\n            conflictOccurred(schedulerData, action, item, type, slotId, slotName, newStart, newEnd);\n          } else {\n            console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\n          }\n        } else {\n          if (isEvent) {\n            if (moveEvent !== undefined) {\n              moveEvent(schedulerData, item, slotId, slotName, newStart, newEnd);\n            }\n          } else {\n            if (newEvent !== undefined) newEvent(schedulerData, slotId, slotName, newStart, newEnd, type, item);\n          }\n        }\n      },\n      canDrag: function canDrag(props) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n\n        var item = _this.resolveDragObjFunc(props);\n\n        if (schedulerData._isResizing()) return false;\n        var config = schedulerData.config;\n        return config.movable && (resourceEvents == undefined || !resourceEvents.groupOnly) && (item.movable == undefined || item.movable !== false);\n      }\n    };\n  };\n\n  this.getDragCollect = function (connect, monitor) {\n    return {\n      connectDragSource: connect.dragSource(),\n      isDragging: monitor.isDragging(),\n      connectDragPreview: connect.dragPreview()\n    };\n  };\n\n  this.getDragSource = function () {\n    return _this.dragSource;\n  };\n\n  this.resolveDragObjFunc = resolveDragObjFunc;\n  this.DecoratedComponent = DecoratedComponent;\n  this.dndType = dndType;\n  this.dragSource = (0, _reactDnd.DragSource)(this.dndType, this.getDragSpec(), this.getDragCollect)(this.DecoratedComponent);\n};\n\nexports.default = DnDSource;","map":{"version":3,"sources":["/home/danielmelchor/Documents/CodeProjects/nexus/frontend/node_modules/react-big-scheduler/lib/DnDSource.js"],"names":["Object","defineProperty","exports","value","default","undefined","_reactDnd","require","_index","_DnDTypes","_classCallCheck","instance","Constructor","TypeError","DnDSource","resolveDragObjFunc","DecoratedComponent","_this","dndType","arguments","length","DnDTypes","EVENT","getDragSpec","beginDrag","props","monitor","component","endDrag","didDrop","moveEvent","newEvent","schedulerData","events","config","viewType","localeMoment","item","getItem","type","getItemType","dropResult","getDropResult","slotId","slotName","newStart","start","newEnd","end","initialStart","initialEnd","action","isEvent","event","relativeMove","add","diff","format","DATETIME_FORMAT","ViewTypes","Day","tmpMoment","year","month","date","crossResourceMove","_getEventSlotId","slot","getSlotById","name","hasConflict","checkConflict","forEach","e","id","eStart","eEnd","conflictOccurred","console","log","canDrag","resourceEvents","_isResizing","movable","groupOnly","getDragCollect","connect","connectDragSource","dragSource","isDragging","connectDragPreview","dragPreview","getDragSource","DragSource"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _index = require('./index');\n\nvar _DnDTypes = require('./DnDTypes');\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DnDSource = function DnDSource(resolveDragObjFunc, DecoratedComponent) {\n    var _this = this;\n\n    var dndType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _DnDTypes.DnDTypes.EVENT;\n\n    _classCallCheck(this, DnDSource);\n\n    this.getDragSpec = function () {\n        return {\n            beginDrag: function beginDrag(props, monitor, component) {\n                return _this.resolveDragObjFunc(props);\n            },\n            endDrag: function endDrag(props, monitor, component) {\n                if (!monitor.didDrop()) return;\n\n                var moveEvent = props.moveEvent,\n                    newEvent = props.newEvent,\n                    schedulerData = props.schedulerData;\n                var events = schedulerData.events,\n                    config = schedulerData.config,\n                    viewType = schedulerData.viewType,\n                    localeMoment = schedulerData.localeMoment;\n\n                var item = monitor.getItem();\n                var type = monitor.getItemType();\n                var dropResult = monitor.getDropResult();\n                var slotId = dropResult.slotId,\n                    slotName = dropResult.slotName;\n                var newStart = dropResult.start,\n                    newEnd = dropResult.end;\n                var initialStart = dropResult.initialStart,\n                    initialEnd = dropResult.initialEnd;\n                var action = 'New';\n\n                var isEvent = type === _DnDTypes.DnDTypes.EVENT;\n                if (isEvent) {\n                    var event = item;\n                    if (config.relativeMove) {\n                        newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(_index.DATETIME_FORMAT);\n                    } else {\n                        if (viewType !== _index.ViewTypes.Day) {\n                            var tmpMoment = localeMoment(newStart);\n                            newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(_index.DATETIME_FORMAT);\n                        }\n                    }\n                    newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(_index.DATETIME_FORMAT);\n\n                    //if crossResourceMove disabled, slot returns old value\n                    if (config.crossResourceMove === false) {\n                        slotId = schedulerData._getEventSlotId(item);\n                        slotName = undefined;\n                        var slot = schedulerData.getSlotById(slotId);\n                        if (!!slot) slotName = slot.name;\n                    }\n\n                    action = 'Move';\n                }\n\n                var hasConflict = false;\n                if (config.checkConflict) {\n                    var start = localeMoment(newStart),\n                        end = localeMoment(newEnd);\n\n                    events.forEach(function (e) {\n                        if (schedulerData._getEventSlotId(e) === slotId && (!isEvent || e.id !== item.id)) {\n                            var eStart = localeMoment(e.start),\n                                eEnd = localeMoment(e.end);\n                            if (start >= eStart && start < eEnd || end > eStart && end <= eEnd || eStart >= start && eStart < end || eEnd > start && eEnd <= end) hasConflict = true;\n                        }\n                    });\n                }\n\n                if (hasConflict) {\n                    var conflictOccurred = props.conflictOccurred;\n\n                    if (conflictOccurred != undefined) {\n                        conflictOccurred(schedulerData, action, item, type, slotId, slotName, newStart, newEnd);\n                    } else {\n                        console.log('Conflict occurred, set conflictOccurred func in Scheduler to handle it');\n                    }\n                } else {\n                    if (isEvent) {\n                        if (moveEvent !== undefined) {\n                            moveEvent(schedulerData, item, slotId, slotName, newStart, newEnd);\n                        }\n                    } else {\n                        if (newEvent !== undefined) newEvent(schedulerData, slotId, slotName, newStart, newEnd, type, item);\n                    }\n                }\n            },\n\n            canDrag: function canDrag(props) {\n                var schedulerData = props.schedulerData,\n                    resourceEvents = props.resourceEvents;\n\n                var item = _this.resolveDragObjFunc(props);\n                if (schedulerData._isResizing()) return false;\n                var config = schedulerData.config;\n\n                return config.movable && (resourceEvents == undefined || !resourceEvents.groupOnly) && (item.movable == undefined || item.movable !== false);\n            }\n        };\n    };\n\n    this.getDragCollect = function (connect, monitor) {\n        return {\n            connectDragSource: connect.dragSource(),\n            isDragging: monitor.isDragging(),\n            connectDragPreview: connect.dragPreview()\n        };\n    };\n\n    this.getDragSource = function () {\n        return _this.dragSource;\n    };\n\n    this.resolveDragObjFunc = resolveDragObjFunc;\n    this.DecoratedComponent = DecoratedComponent;\n    this.dndType = dndType;\n    this.dragSource = (0, _reactDnd.DragSource)(this.dndType, this.getDragSpec(), this.getDragCollect)(this.DecoratedComponent);\n};\n\nexports.default = DnDSource;"]},"metadata":{},"sourceType":"script"}