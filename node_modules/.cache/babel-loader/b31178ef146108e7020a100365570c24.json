{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _Util = require('./Util');\n\nvar _DnDTypes = require('./DnDTypes');\n\nvar _index = require('./index');\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar DnDContext = function DnDContext(sources, DecoratedComponent) {\n  var _this = this;\n\n  _classCallCheck(this, DnDContext);\n\n  this.getDropSpec = function () {\n    return {\n      drop: function drop(props, monitor, component) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n        var cellUnit = schedulerData.cellUnit,\n            localeMoment = schedulerData.localeMoment;\n        var type = monitor.getItemType();\n        var pos = (0, _Util.getPos)(component.eventContainer);\n        var cellWidth = schedulerData.getContentCellWidth();\n        var initialStartTime = null,\n            initialEndTime = null;\n\n        if (type === _DnDTypes.DnDTypes.EVENT) {\n          var initialPoint = monitor.getInitialClientOffset();\n          var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n          initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\n          initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\n          if (cellUnit !== _index.CellUnits.Hour) initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        }\n\n        var point = monitor.getClientOffset();\n        var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n        var startTime = resourceEvents.headerItems[leftIndex].start;\n        var endTime = resourceEvents.headerItems[leftIndex].end;\n        if (cellUnit !== _index.CellUnits.Hour) endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        return {\n          slotId: resourceEvents.slotId,\n          slotName: resourceEvents.slotName,\n          start: startTime,\n          end: endTime,\n          initialStart: initialStartTime,\n          initialEnd: initialEndTime\n        };\n      },\n      hover: function hover(props, monitor, component) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents,\n            movingEvent = props.movingEvent;\n        var cellUnit = schedulerData.cellUnit,\n            config = schedulerData.config,\n            viewType = schedulerData.viewType,\n            localeMoment = schedulerData.localeMoment;\n        var item = monitor.getItem();\n        var type = monitor.getItemType();\n        var pos = (0, _Util.getPos)(component.eventContainer);\n        var cellWidth = schedulerData.getContentCellWidth();\n        var initialStart = null,\n            initialEnd = null;\n\n        if (type === _DnDTypes.DnDTypes.EVENT) {\n          var initialPoint = monitor.getInitialClientOffset();\n          var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n          initialStart = resourceEvents.headerItems[initialLeftIndex].start;\n          initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\n          if (cellUnit !== _index.CellUnits.Hour) initialEnd = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        }\n\n        var point = monitor.getClientOffset();\n        var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n        var newStart = resourceEvents.headerItems[leftIndex].start;\n        var newEnd = resourceEvents.headerItems[leftIndex].end;\n        if (cellUnit !== _index.CellUnits.Hour) newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n        var slotId = resourceEvents.slotId,\n            slotName = resourceEvents.slotName;\n        var action = 'New';\n        var isEvent = type === _DnDTypes.DnDTypes.EVENT;\n\n        if (isEvent) {\n          var event = item;\n\n          if (config.relativeMove) {\n            newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(_index.DATETIME_FORMAT);\n          } else {\n            if (viewType !== ViewTypes.Day) {\n              var tmpMoment = localeMoment(newStart);\n              newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(_index.DATETIME_FORMAT);\n            }\n          }\n\n          newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(_index.DATETIME_FORMAT); //if crossResourceMove disabled, slot returns old value\n\n          if (config.crossResourceMove === false) {\n            slotId = schedulerData._getEventSlotId(item);\n            slotName = undefined;\n            var slot = schedulerData.getSlotById(slotId);\n            if (!!slot) slotName = slot.name;\n          }\n\n          action = 'Move';\n        }\n\n        if (!!movingEvent) {\n          movingEvent(schedulerData, slotId, slotName, newStart, newEnd, action, type, item);\n        }\n      },\n      canDrop: function canDrop(props, monitor) {\n        var schedulerData = props.schedulerData,\n            resourceEvents = props.resourceEvents;\n        var item = monitor.getItem();\n        if (schedulerData._isResizing()) return false;\n        var config = schedulerData.config;\n        return config.movable && !resourceEvents.groupOnly && (item.movable == undefined || item.movable !== false);\n      }\n    };\n  };\n\n  this.getDropCollect = function (connect, monitor) {\n    return {\n      connectDropTarget: connect.dropTarget(),\n      isOver: monitor.isOver()\n    };\n  };\n\n  this.getDropTarget = function () {\n    return (0, _reactDnd.DropTarget)([].concat(_toConsumableArray(_this.sourceMap.keys())), _this.getDropSpec(), _this.getDropCollect)(_this.DecoratedComponent);\n  };\n\n  this.getDndSource = function () {\n    var dndType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DnDTypes.DnDTypes.EVENT;\n    return _this.sourceMap.get(dndType);\n  };\n\n  this.sourceMap = new Map();\n  sources.forEach(function (item) {\n    _this.sourceMap.set(item.dndType, item);\n  });\n  this.DecoratedComponent = DecoratedComponent;\n};\n\nexports.default = DnDContext;","map":{"version":3,"sources":["/home/danielmelchor/Documents/CodeProjects/nexus/frontend/node_modules/react-big-scheduler/lib/DnDContext.js"],"names":["Object","defineProperty","exports","value","default","undefined","_reactDnd","require","_Util","_DnDTypes","_index","_toConsumableArray","arr","Array","isArray","i","arr2","length","from","_classCallCheck","instance","Constructor","TypeError","DnDContext","sources","DecoratedComponent","_this","getDropSpec","drop","props","monitor","component","schedulerData","resourceEvents","cellUnit","localeMoment","type","getItemType","pos","getPos","eventContainer","cellWidth","getContentCellWidth","initialStartTime","initialEndTime","DnDTypes","EVENT","initialPoint","getInitialClientOffset","initialLeftIndex","Math","floor","x","headerItems","start","end","CellUnits","Hour","hour","minute","second","format","DATETIME_FORMAT","point","getClientOffset","leftIndex","startTime","endTime","slotId","slotName","initialStart","initialEnd","hover","movingEvent","config","viewType","item","getItem","newStart","newEnd","action","isEvent","event","relativeMove","add","diff","ViewTypes","Day","tmpMoment","year","month","date","crossResourceMove","_getEventSlotId","slot","getSlotById","name","canDrop","_isResizing","movable","groupOnly","getDropCollect","connect","connectDropTarget","dropTarget","isOver","getDropTarget","DropTarget","concat","sourceMap","keys","getDndSource","dndType","arguments","get","Map","forEach","set"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = undefined;\n\nvar _reactDnd = require('react-dnd');\n\nvar _Util = require('./Util');\n\nvar _DnDTypes = require('./DnDTypes');\n\nvar _index = require('./index');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DnDContext = function DnDContext(sources, DecoratedComponent) {\n    var _this = this;\n\n    _classCallCheck(this, DnDContext);\n\n    this.getDropSpec = function () {\n        return {\n            drop: function drop(props, monitor, component) {\n                var schedulerData = props.schedulerData,\n                    resourceEvents = props.resourceEvents;\n                var cellUnit = schedulerData.cellUnit,\n                    localeMoment = schedulerData.localeMoment;\n\n                var type = monitor.getItemType();\n                var pos = (0, _Util.getPos)(component.eventContainer);\n                var cellWidth = schedulerData.getContentCellWidth();\n                var initialStartTime = null,\n                    initialEndTime = null;\n                if (type === _DnDTypes.DnDTypes.EVENT) {\n                    var initialPoint = monitor.getInitialClientOffset();\n                    var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n                    initialStartTime = resourceEvents.headerItems[initialLeftIndex].start;\n                    initialEndTime = resourceEvents.headerItems[initialLeftIndex].end;\n                    if (cellUnit !== _index.CellUnits.Hour) initialEndTime = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n                }\n                var point = monitor.getClientOffset();\n                var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n                var startTime = resourceEvents.headerItems[leftIndex].start;\n                var endTime = resourceEvents.headerItems[leftIndex].end;\n                if (cellUnit !== _index.CellUnits.Hour) endTime = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n\n                return {\n                    slotId: resourceEvents.slotId,\n                    slotName: resourceEvents.slotName,\n                    start: startTime,\n                    end: endTime,\n                    initialStart: initialStartTime,\n                    initialEnd: initialEndTime\n                };\n            },\n\n            hover: function hover(props, monitor, component) {\n                var schedulerData = props.schedulerData,\n                    resourceEvents = props.resourceEvents,\n                    movingEvent = props.movingEvent;\n                var cellUnit = schedulerData.cellUnit,\n                    config = schedulerData.config,\n                    viewType = schedulerData.viewType,\n                    localeMoment = schedulerData.localeMoment;\n\n                var item = monitor.getItem();\n                var type = monitor.getItemType();\n                var pos = (0, _Util.getPos)(component.eventContainer);\n                var cellWidth = schedulerData.getContentCellWidth();\n                var initialStart = null,\n                    initialEnd = null;\n                if (type === _DnDTypes.DnDTypes.EVENT) {\n                    var initialPoint = monitor.getInitialClientOffset();\n                    var initialLeftIndex = Math.floor((initialPoint.x - pos.x) / cellWidth);\n                    initialStart = resourceEvents.headerItems[initialLeftIndex].start;\n                    initialEnd = resourceEvents.headerItems[initialLeftIndex].end;\n                    if (cellUnit !== _index.CellUnits.Hour) initialEnd = localeMoment(resourceEvents.headerItems[initialLeftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n                }\n                var point = monitor.getClientOffset();\n                var leftIndex = Math.floor((point.x - pos.x) / cellWidth);\n                var newStart = resourceEvents.headerItems[leftIndex].start;\n                var newEnd = resourceEvents.headerItems[leftIndex].end;\n                if (cellUnit !== _index.CellUnits.Hour) newEnd = localeMoment(resourceEvents.headerItems[leftIndex].start).hour(23).minute(59).second(59).format(_index.DATETIME_FORMAT);\n                var slotId = resourceEvents.slotId,\n                    slotName = resourceEvents.slotName;\n                var action = 'New';\n                var isEvent = type === _DnDTypes.DnDTypes.EVENT;\n                if (isEvent) {\n                    var event = item;\n                    if (config.relativeMove) {\n                        newStart = localeMoment(event.start).add(localeMoment(newStart).diff(localeMoment(initialStart)), 'ms').format(_index.DATETIME_FORMAT);\n                    } else {\n                        if (viewType !== ViewTypes.Day) {\n                            var tmpMoment = localeMoment(newStart);\n                            newStart = localeMoment(event.start).year(tmpMoment.year()).month(tmpMoment.month()).date(tmpMoment.date()).format(_index.DATETIME_FORMAT);\n                        }\n                    }\n                    newEnd = localeMoment(newStart).add(localeMoment(event.end).diff(localeMoment(event.start)), 'ms').format(_index.DATETIME_FORMAT);\n\n                    //if crossResourceMove disabled, slot returns old value\n                    if (config.crossResourceMove === false) {\n                        slotId = schedulerData._getEventSlotId(item);\n                        slotName = undefined;\n                        var slot = schedulerData.getSlotById(slotId);\n                        if (!!slot) slotName = slot.name;\n                    }\n\n                    action = 'Move';\n                }\n\n                if (!!movingEvent) {\n                    movingEvent(schedulerData, slotId, slotName, newStart, newEnd, action, type, item);\n                }\n            },\n\n            canDrop: function canDrop(props, monitor) {\n                var schedulerData = props.schedulerData,\n                    resourceEvents = props.resourceEvents;\n\n                var item = monitor.getItem();\n                if (schedulerData._isResizing()) return false;\n                var config = schedulerData.config;\n\n                return config.movable && !resourceEvents.groupOnly && (item.movable == undefined || item.movable !== false);\n            }\n        };\n    };\n\n    this.getDropCollect = function (connect, monitor) {\n        return {\n            connectDropTarget: connect.dropTarget(),\n            isOver: monitor.isOver()\n        };\n    };\n\n    this.getDropTarget = function () {\n        return (0, _reactDnd.DropTarget)([].concat(_toConsumableArray(_this.sourceMap.keys())), _this.getDropSpec(), _this.getDropCollect)(_this.DecoratedComponent);\n    };\n\n    this.getDndSource = function () {\n        var dndType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _DnDTypes.DnDTypes.EVENT;\n\n        return _this.sourceMap.get(dndType);\n    };\n\n    this.sourceMap = new Map();\n    sources.forEach(function (item) {\n        _this.sourceMap.set(item.dndType, item);\n    });\n    this.DecoratedComponent = DecoratedComponent;\n};\n\nexports.default = DnDContext;"]},"metadata":{},"sourceType":"script"}